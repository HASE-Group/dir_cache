//
// Project:	Directory-based Coherence: singly-linked list
// Entity	Memory
// File		memory.hase
// Date:	Jun 2006
// Author:	Roland Ibbett

// The Memory receives Read and Write requests from the caches.
// Each line in the Memory contains a data field and a directory
// field, the latter containing a pointer to the first cache in the list
// for that memory line. In principle, memory and cache lines could be
// longer than just one word.

$class_decls

bool send_to_network;
net_struct pkt_from_network;
net_struct pkt_to_network;
int head, addr, data_in, data_out;
int source, dest, pointer;
int count, i, counter;
char instr[5];
mem_struct mem_buff;


void handle_read();
void handle_write();
void handle_invalidate();
void progress_queue(int j);

$class_defs

void memory::handle_read(){

/*
The Memory returns an RD packet to the requesting cache containing the
current directory entry for the requested line in the pointer field
and updates its directory entry to be equal to the value in the source
field in the incoming packet.
If the directory entry is 0, the requesting cache becomes the tail of
the list.
If the directory entry is not 0, the requesting cache prepends itself
to the cache indentified in the pointer field. 
*/
        pkt_to_network.addr = addr;
        pkt_to_network.data = data_mem[addr].data;
	pkt_to_network.dest = source;
	pkt_to_network.source = 0;
	pkt_to_network.pointer = data_mem[addr].head;
	strcpy(pkt_to_network.instr,"RA");
	mem_buff.data = data_mem[addr].data;
	mem_buff.head = source;

	data_mem.Update(addr,mem_buff);
	send_to_network = true;
}

void memory::handle_write(){

/* If the source number is equal to the directory entry and the
pointer field value is -1, or the directory entry is 0, the Memory
just sends a Write Acknowledge, with its current data (because in
principle, lines could contain more than one word).  If neither of
these, the Memory sends an IV packet to the cache identified by the
current directory entry (along with the data and with the source
number in the pointer field) and sets the directory entry equal to the
source number. 
*/
	pkt_to_network.addr = addr;
	pkt_to_network.data = data_mem[addr].data;
	pkt_to_network.source = 0;

   if ( ((data_mem[addr].head == source) && (pointer == -1))
	 || (data_mem[addr].head == 0) )
     {
	pkt_to_network.dest = source;
	pkt_to_network.pointer = -1;
        strcpy(pkt_to_network.instr,"WA");
     }
   else
     {
	pkt_to_network.dest = data_mem[addr].head;
	pkt_to_network.pointer = source;
	strcpy(pkt_to_network.instr,"IV");
     }
	mem_buff.data = data_in;
	mem_buff.head = source;
	data_mem.Update(addr,mem_buff);
	send_to_network = true;
}

void memory::handle_invalidate(){

/* A cache has experienced a collision miss, i.e. it needs to use a
line for a different address from the one in the line required by a
new request. The Memory sends an Invalidate request to the cache
indentified for the old address in its directory and sets its
directory entry for that address to 0. The requesting cache will
eventually receive an IA from the tail of the list (or from the Memory
if the sending cache is the tail) and will then issue a write request
for the new addresss. 
*/
	pkt_to_network.addr = addr;
	pkt_to_network.data = 0;
	pkt_to_network.source = 0;
	pkt_to_network.dest = data_mem[addr].head;
	pkt_to_network.pointer = source;
	if (source == data_mem[addr].head)
	 {strcpy(pkt_to_network.instr,"IA");}
	else
	 {strcpy(pkt_to_network.instr,"IV");}
	mem_buff.data = data_mem[addr].data;
	mem_buff.head = 0;
	data_mem.Update(addr,mem_buff);
	send_to_network = true;
}

$pre

  send_to_network = false;
  mem_buff.head=0;
  counter = 0;

  my_state = MEMORY_IDLE;
  dump_state();

$phase0

  sim_from_port Input(from_network);	    

  if  (sim_waiting(ev, Input) > 0)
   {
	my_state = MEMORY_BUSY;
	dump_state();
	SIM_CAST_DEL(net_struct,pkt_from_network,ev);

	 strcpy(instr, pkt_from_network.instr);		
	 addr = pkt_from_network.addr;
	 data_in = pkt_from_network.data;
	 dest = pkt_from_network.dest;
	 source = pkt_from_network.source;
	 pointer = pkt_from_network.pointer;

	  if (strcmp(instr,"RR")==0)
	   {
	    handle_read();
	   }

	 else if (strcmp(instr,"WR")==0)
	   {
	    handle_write();
	   }

	 else if (strcmp(instr,"IV")==0)
	   {
	    handle_invalidate();
	   }
   }

$phase1

  if (send_to_network)
  {
	send_NET_PKT(to_network,pkt_to_network);
	send_to_network = false;
	my_state = MEMORY_IDLE;
	dump_state();
  }


