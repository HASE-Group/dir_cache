//
// Project:	Scalable Coherent Interface
// Entity	Memory
// File		memory.hase
// Date:	Aug 2005
// Author:	Roland Ibbett, based on an early version by Max Magliana


$class_decls

bool send_to_network;
net_struct pkt_from_network;
net_struct pkt_to_network;
int head, addr;
int source, dest, pointer;
int count, i, counter;
int chain_head;
char instr[5];
dir_struct dir_buff;

void handle_read_miss();
void handle_write_miss();
void handle_write_data();
void handle_UP();
void progress_queue(int j);

$class_defs

/** The following method is called to handle a "read Cached" sinal from a cache.
*   If the requested memory line has already been cached, a "HD" signal, containing
*   a pointer to the head of the chain, must be sent to the requester.
*   Otherwise, the requested value must be returned to the requesting cache with a "RD"
*   (Requested Data) signal.
*/

void memory::handle_read_miss(){
        pkt_to_network.addr = addr;
	pkt_to_network.dest = source;
	pkt_to_network.source = 0;
	pkt_to_network.pointer = Directory[addr].head;
	dir_buff.head = source;
	
	if (Directory[addr].head == 0)
	 {strcpy(pkt_to_network.instr,"RD");}
	else
	 {strcpy(pkt_to_network.instr,"HP");}

	Directory.Update(addr,dir_buff);
	send_to_network = true;
}

void memory::handle_write_miss(){

/* An RW (Read before Write) request is treated as a Read request. The
   memory tells the requesting cache that either the value is not cached
   cache (the directory head of the list value is 0) and returns an RD
   packet, of that it is held by another cache, in which case the memory
   returns an HP packet telling the requesting cache to prepend itself
   to the list (it will then do a purge of the list). In either case,
   the memory updates its head pointer to point to the new head of the
   list.
 */

	pkt_to_network.addr = addr;
	pkt_to_network.dest = source;
	pkt_to_network.source = 0;
	pkt_to_network.pointer = Directory[addr].head;
	dir_buff.head = source;

	if ((Directory[addr].head == 0)  || (Directory[addr].head == source))
	 {strcpy(pkt_to_network.instr,"RD");}
	else
	 {strcpy(pkt_to_network.instr,"HP");}

	Directory.Update(addr,dir_buff);
	send_to_network = true;
}


/* The following method handles data writes (it doesn't actually write
data, there isn't any). It sends an acknowledge (AK) to the source cache.
 */

void memory::handle_write_data(){
	dir_buff.head = source;
	Directory.Update(addr, dir_buff);
        pkt_to_network.source = 0;
        pkt_to_network.dest = source;
        pkt_to_network.addr = addr;
        pkt_to_network.pointer = 0;
        strcpy(pkt_to_network.instr,"AK");
	send_to_network = true;
}

/* This method is called when a UP packet is received: a UP is sent
when the head of the list wishes to rollout. The UP packet contains
the successor's successor pointer to telling memory which cache is the
new head. If the pointer is "-1" then the memory line is no longer
cached.
 */

void memory::handle_UP(){

	if (pointer == -1) {
		dir_buff.head = 0;
	} else {
		dir_buff.head = pointer;
	}
	Directory.Update(addr, dir_buff);
	strcpy(pkt_to_network.instr,"PA");
	pkt_to_network.addr = addr;
	pkt_to_network.dest = source;
	pkt_to_network.source = 0;
	pkt_to_network.pointer = 0;
	send_to_network = true;
}

$pre

  send_to_network = false;
  dir_buff.head=0;
  counter = 0;

  my_state = MEMORY_IDLE;
  dump_state();

$phase0

  sim_from_port Input(from_network);	    

  if  (sim_waiting(ev, Input) > 0)
   {
	my_state = MEMORY_BUSY;
	dump_state();
	SIM_CAST_DEL(net_struct,pkt_from_network,ev);

	 strcpy(instr, pkt_from_network.instr);		
	 addr = pkt_from_network.addr;
	 dest = pkt_from_network.dest;
	 source = pkt_from_network.source;
	 pointer = pkt_from_network.pointer;

	  if (strcmp(instr,"RR")==0)
	   {
	    handle_read_miss();
	   }

	  else if (strcmp(instr,"UP")==0)
	   {
	    handle_UP();
	   }

	 else if (strcmp(instr,"RW")==0)
	   {
	    handle_write_miss();
	   }

   }

$phase1

  if (send_to_network)
  {
	send_NET_PKT(to_network,pkt_to_network);
	send_to_network = false;
	my_state = MEMORY_IDLE;
	dump_state();
  }


