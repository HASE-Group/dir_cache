c// Project:	Directory-based Coherence: singly-linked list
// Entity	Cache
// File		cache.hase
// Date:	Jun 2006
// Author:	Roland Ibbett, based on dir-cache V3

// Each line in the cache contains the following (integer) fields
// in each of its 4 lines:
// Valid
// Address
// Pointer to successor in list

// Packets contain the following fields:
// Address: corresponds to a valid memory address
// Source: indicates the source of the packet
// Destination: indicates where the packet is going
// Pointer: 
// Instruction, which can be one of the following:

// R	Read			Sent from processor to cache.
// W	Write			Sent from memory to cache
// RR	Read Request		Sent from cache to memory.
// WR	Write Request 		Sent from cache to memory.
// RA	Read Acknowledge	Sent from memory to cache
// IV	Invalidate		Sent from memory or cache 
// IA	Invalidate Acknowledge	Sent from last cache in list to new head

/*
A cache receives packets from its processor and from the network
A packet from a processor can be a read request or a write request
The response to a read request may be
RH - Read Hit: the cache returns the requested data to the processor
RME - Read Miss on an Empty Line: the cache requests the data from
      Memory
RMV - Read Miss on a line containing a different Valid address:
      the cache sends an invalidate request to Memory and
      when it receives an Acknowledge, issues a read request;
      the Acknowledge may come from Memory (if the cache was the
      tail) or from another cache.
The response to a write request may be
WH - Write Hit: cache writes to itself and memory and gets either
     a Write Acknowledgement from Memory (if it's the only cache
     with a copy) or an Invalidate Acknowledge from another cache.
WME - Write Miss on an Empty line: the cache requests the data fromm
      Memory; Memory and cache update their lines.
WMV - Write Miss on a line containing a different valid address:
      the cache sends an invalidate request to Memory and
      when it receives an Acknowledge, issues a write request
*/         


$class_decls

bool read_request, write_request;
bool send_to_network, send_to_proc;
bool awaiting_ia;
bool done;

char instr[5];

int addr, n_data, p_data;
int count;
int own_no;
int successor;
char * name;
int line, current_line, line_mask;
int Cache_size;

mem_trace_struct pkt_from_proc;
net_struct pkt_to_network;
net_struct pkt_from_network;

cache_struct cache_buff,new_block;

void issue_read();
void issue_write();
void write_data();
void issue_invalidate();
void handle_read();
void handle_write();
void handle_from_network();

$class_defs

void cache::issue_read(){

	strcpy(pkt_to_network.instr,"RR");
	pkt_to_network.addr = pkt_from_proc.addr;
	pkt_to_network.data = 0;
	pkt_to_network.dest = 0;
	pkt_to_network.source = own_no;
	pkt_to_network.pointer = cache_buff.successor;
	send_to_network = true;
}

void cache::issue_write(){

	strcpy(pkt_to_network.instr,"WR");
	pkt_to_network.addr = pkt_from_proc.addr;
	pkt_to_network.data = pkt_from_proc.data;
	pkt_to_network.dest = 0;
	pkt_to_network.source = own_no;
	pkt_to_network.pointer = cache_buff.successor;
	send_to_network = true;
}

void cache::write_data(){

	 new_block.valid = 1;
	 new_block.address = addr;
	 new_block.data = n_data;
	 new_block.successor = -1;
	 cache_mem.Update(current_line,new_block);	// write mem data
	 new_block.data = p_data;
	 cache_mem.Update(current_line,new_block);	// write new data
	 send_to_proc = true;
	 done = true;
}

void cache::issue_invalidate(){	

/* Called when a cache miss is to a line containing a different valid
address.
 */
	pkt_to_network.addr = cache_buff.address;
	pkt_to_network.data = 0;
	pkt_to_network.source = own_no;
	pkt_to_network.dest = 0;
	pkt_to_network.pointer = cache_buff.successor;
	strcpy(pkt_to_network.instr,"IV");
	awaiting_ia = true;
	send_to_network = true;
}

void cache::handle_read(){	
/*
Called when the cache receives a Read Request
*/
	read_request = true;
	if (cache_buff.valid == 1)		// line in use
	 {
	  if (cache_buff.address == addr)
		{				// read hit
		 strcpy(Status, "RH");
		 dump_state();
	 	 pkt_from_proc.data = cache_buff.data;
		 send_to_proc = true;
		 done = true;
		}
	  else					// read miss
		{
		 strcpy(Status, "RMV");
		 dump_state();
		 issue_invalidate();
		 }
	 }
	else					// line empty
	  {
		 strcpy(Status, "RME");
	   	 dump_state();
	   	 issue_read();
	   }
}

void cache::handle_write(){

/* 
Called when the cache receives a Write Request
 */
	write_request = true;
	if (cache_buff.valid == 1)		// line in use
	 {
	  if (cache_buff.address == addr)	// write hit
		{
		 strcpy(Status, "WH");
		 dump_state();
		 issue_write();
		}
 	  else					// write miss
		  {
		   strcpy(Status, "WMV");
		   dump_state();
		   issue_invalidate();
		  }
	 }
	else					// line empty
	  {
		 strcpy(Status, "WME");
	   	 dump_state();
	   	 issue_write();
	   }
}

void cache::handle_from_network(){

/* This method is called when a packet arrives from the network.
   Different actions occur according to the instr field in the packet.

RA: Read Acknowledge

WA: Write Acknowledge

IV: Invalidate

IA: Invalidate Acknowledge
 */

/* RA: 
When an RA packet is received, the data is written to the cache
and, in the case of a read request, forwarded to the processor.

If the pointer field is = 0, the cache becomes the tail of the list
If the pointer field is != 0, the cache prepends itself to the
list by copying the pointer field into its successor field.
*/
   if (strcmp(instr,"RA") == 0)
	 {
	  cache_buff.address = addr;
	  cache_buff.data = n_data;
	  cache_buff.valid = 1;

	  if (pkt_from_network.pointer == 0)	// Tail of list	
	    {cache_buff.successor = -1;}
	  else					// Prepend to list
	    {cache_buff.successor = pkt_from_network.pointer;}

	 cache_mem.Update(current_line,cache_buff);
	 read_request = false;
	 pkt_from_proc.data = n_data;
	 send_to_proc = true;
	 done = true;
	}	// end of RD

/* IV:
Copy data in input packet to output
If successor field != -1, send an IV packet to the cache identified
in own successor field
If successor field = -1, send an IA packet to the cache identified
in the pointer field.
Clear line in cache containing address in the packet.
*/
	if (strcmp(instr,"IV") == 0) {
	pkt_to_network.addr = pkt_from_network.addr;
	line = pkt_from_network.addr & line_mask;	
	pkt_to_network.data = n_data;
	pkt_to_network.source = own_no;
	if (cache_buff.successor != -1)
	 {
	  strcpy(pkt_to_network.instr,"IV");
	  pkt_to_network.dest = cache_buff.successor;
	  pkt_to_network.pointer = pkt_from_network.pointer;
	 }
	else
	 {
	  strcpy(pkt_to_network.instr,"IA");
	  pkt_to_network.dest = pkt_from_network.pointer;
	  pkt_to_network.pointer = 0;
	 }
	new_block.valid = 0;
	new_block.address= 0;
	new_block.data = 0;
	new_block.successor= 0;
	cache_mem.Update(line,new_block);
	send_to_network = true;
	}

/* IA:
An IA packet arrives in response to an IV or a WR packet sent to Memory,
either in response to a Write Request or to an Invalidate Request (sent
because of a conflict miss)
If a Write Request is outstanding, the write can now complete.
If an Invalidate request is outstanding, the read or write
request can now be issued.
 */
   if ( strcmp(instr,"IA") == 0) {
	if (awaiting_ia)
	 {
	  issue_write();
	  awaiting_ia = false;
	 }
	else
	 {write_data();} 
}

/* WA:
Reply from Memory in response to Write Request when cache is tail of list
Update the cache and send an ack to the processor
*/
        if (strcmp(instr,"WA")==0) {
		write_data();
		write_request = false;
		send_to_proc = true;
		done = true;
        }
}

$pre

  done = false;
  awaiting_ia = false;
  read_request = false;
  write_request = false;
  send_to_network = false;
  send_to_proc = false;

  Cache_size = 1 << cache_size;
  line_mask = (1 << cache_size) -1;

  name = get_name();
  if (strcmp(name,"CACHE1")==0) {own_no=1;}
  if (strcmp(name,"CACHE2")==0) {own_no=2;}
  if (strcmp(name,"CACHE3")==0) {own_no=3;}
  if (strcmp(name,"CACHE4")==0) {own_no=4;}

/*The following lines reset the values for the animation*/

  new_block.valid = 0;
  new_block.data= 0;
  new_block.address= 0;
  new_block.successor= 0;
  for (count=0;count<Cache_size;count++)
    {cache_mem.Update(count,new_block);}

  my_state = CACHE_IDLE;
  dump_state();

$phase0

  sim_from_port P_Input(from_proc);	    
  sim_from_port N_Input(from_network);	    

  if  (sim_waiting(ev, P_Input) > 0)
   {
     nodes_done_mutex.Lock();
     nodes_done--;
     dump_globals();
     nodes_done_mutex.Unlock();
    my_state = CACHE_BUSY;
    dump_state();
    SIM_CAST(mem_trace_struct, pkt_from_proc,ev);
    strcpy(instr,pkt_from_proc.instr);
    addr = pkt_from_proc.addr;
    p_data = pkt_from_proc.data;
    current_line = addr & line_mask;
    cache_buff = cache_mem[current_line];
    if  (strcmp(instr,"R") == 0)
	 {handle_read();}
	if (strcmp(instr,"r") == 0)
	 {handle_read();}
	if (strcmp(instr,"W") == 0)
	  {handle_write();}
	if (strcmp(instr,"w") == 0)
	  {handle_write();}
    }

  if  (sim_waiting(ev, N_Input) > 0)  //pkt from network
   {
    SIM_CAST(net_struct, pkt_from_network, ev);
    strcpy(instr,pkt_from_network.instr);
    addr=pkt_from_network.addr;
    n_data=pkt_from_network.data;
    current_line = addr & line_mask;
    cache_buff = cache_mem[current_line];
    handle_from_network();
   }

$phase1

  if (send_to_network)
   {
    send_NET_PKT(to_network,pkt_to_network);
    send_to_network = false;
   }
  if (send_to_proc)
   {
    send_DATA_PKT(to_proc,pkt_from_proc);
    send_to_proc = false;
   }
  if (done)
   {
    nodes_done_mutex.Lock();
    nodes_done++;
    dump_globals();
    nodes_done_mutex.Unlock();
    done = false;
    strcpy(Status, "__");
    my_state = CACHE_IDLE;
    dump_state();
   }






